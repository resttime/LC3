(defparameter *memory* (make-array #xFFFF :element-type '(unsigned-byte 16)))
(defparameter *registers* (make-array 10 :element-type '(unsigned-byte 16)))
(defparameter *operations*'(br add ld st jsr and ldr str rti not ldi sti jmp res lea trap))
(defparameter *flags* '(pos zro neg))

'(add (op 4 12) (dr 3 9) (sr1 3 6) (mode 1 5) (sr2 3 0) (imm5 5 0))
'(and (op 4 12) (dr 3 9) (sr1 3 6) (mode 1 5) (sr2 3 0) (imm5 5 0))
'(br (op 4 12) (n 1 11) (z 1 10) (p 1 9) (pcoffset9 9 0))
'(jmp (op 4 12) (baser 3 6))
'(jsr (op 4 12) (mode 1 11) (pcoffset9 11 0) (baser 3 6))
'(ld (op 4 12) (dr 3 9) (pcoffset9 9 0))
'(ldi (op 4 12) (dr 3 9) (pcoffset9 9 0))
'(ldr (op 4 12) (dr 3 9) (baser 3 6) (offset6 6 0))
'(lea (op 4 12) (dr 3 9) (pcoffset9 9 0))
'(not (op 4 12) (dr 3 9) (sr 3 6))
'(ret (op 4 12))
'(rti (op 4 12))
'(st (op 4 12) (sr 3 9) (pcoffset9 9 0))
'(sti (op 4 12) (sr 3 9) (pcoffset9 9 0))
'(str (op 4 12) (sr 3 9) (offset6 6 0))
'(trap (op 4 12) (trapvect8 8 0))
'(res (op 4 12))

(defun perform (instruction)
  (let ((opcode (nth (ldb (byte 4 12) instruction) *operations*)))
    (case opcode
      (add (values (ldb (byte 3 9) instruction)
                   (ldb (byte 3 6) instruction)
                   (ldb (byte 1 5) instruction)
                   (ldb (byte 3 0) instruction))))))
